{--21.1
При помощи оператора >>= для списков описать функцию tripleOdd, 
которая в данном списке все нечетные числа повторяет три раза, 
а остальные оставляет, как есть.

Пример вызова:

tripleOdd [1, 2, 6, 3]

Должно получиться:
[1,1,1,2,6,3,3,3]--}


tripleOdd xs = xs >>= (\x -> if odd x 
                             then [x, x, x]
                             else [x] )



------------------------------------------------------------------
{--21.2
Описать функцию cartesian, которая для двух списков возвращает список 
из всех возможных пар элементов из первого и второго списка. 
Т.е., например, для списков [x1, x2, x3] и [y1, y2, y3] функция должна вернуть 
[(x1, y1), (x1, y2), (x1, y3), (x2, y1), (x2, y2), …] (всего 9 пар).

При этом желательно использовать только оператор >>= и лямбда выражения. 
Можно, но не очень нужно, определять вспомогательные функции. 

Если не получится сделать задачу с помощью >>=, можно написать любым способом, 
но только не используя list comprehension (с ним это уж слишком просто).

Пример вызова:

cartesian [1,2] [3,4]

Должно получиться:
[(1,3),(1,4),(2,3),(2,4)]--}

cartesian xs ys = xs >>= (\x -> (ys >>= (\y -> [(x, y)] )))


----------------------------------------------------------------------------------
{--21.3
Опишите функцию findMajor, которая для данного списка определяет, 
есть ли в нем элемент, который больше суммы всех остальных, вместе взятых, 
и, если есть, возвращает его, как результат.

Для того, чтобы сообщить, есть такой элемент или нет, используйте стандартный тип Maуbe, 
который описан в последних слайдах.

Примеры вызова:

findMajor [2,3,15,2,2,2] 

Должно получиться:
Just 15

findMajor [2,3,5,2,4] 

Должно получиться:
Nothing

Замечания:
- Тут никаких хитростей, это простое упражнение на использование Maybe--}

--data Maybe a = Just a | Nothing


findMajor' [] _ = Nothing
findMajor' (x:xs) sum' = if x >= sum' - x
                         then Just x
                         else findMajor' xs sum'

findMajor xs = findMajor' xs (sum xs)