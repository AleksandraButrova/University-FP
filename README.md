Решенные задания по курсу "Функциональное программирование".


Номер домашнего задания	Номер задачи в задании	Условие	Результат	Посмотреть загруженные решения	Срок сдачи
36	1	*Чтo-то похожее на return*

Пусть мы хотим, чтобы можно было написать: 

f = find (>3) >>>= \x ->
...find (>x) >>>= \y ->
...return1 (x+y)

(как обычно, точки обозначают пробелы).
И в результате f должна работать так: она ищет в списке первый элемент, больший 3, потом первый элемент, больший первого найденного и возвращает пару (сумма двух найденных чисел, хвост списка).

>>>= мы уже определили на занятиях. Определите return1.

(Подсказка: как это обычно бывает с return, это очень простая функция).
Пример вызова f:

f [1,2,8,4,9,3,25]

Должно получиться (17, [3,25]), потому что первый поиск найдет 8, второй - 9.

Замечание:
- чтобы тесты прошли, в программу надо также переписать определения find и >>>= из слайдов	Зачтено	

2016-12-07 09:30:00
36	2	*Чтo-то похожее на елочку, по поводу приближающегося Нового Года*

Опишите функцию elka, которая для данного n печатает n треугольников из семерок, каждый высотой и шириной n. 

Пример вызова:

elka 3

Должно быть напечатано:

7
77
777
7
77
777
7
77
777
Зачтено	

2016-12-07 09:30:00
36	4	Я сказал на занятии примерно следующее:
Выражение
(\x -> E) a
всегда можно без изменения смысла выражения заменить на Е в котором все вхождения x заменены на a

Например,
(\x->mult x x)5
это то же, что
mult 5 5

На самом деле я немного ошибся. Для более сложных выражений это правило не всегда верно, его надо как-то уточнить.

а. Приведите пример, когда это не так
б. Напишите, как сформулировать правило бета редукции более корректно.

Замечания:
- Это не задача на программирование. Ответом д.б. текст, что-то вроде: "Вот пример, когда ваше правило дает неправильные результаты: … какой-то пример … . Его можно исправить так: … правильная формулировка … .
- На самом деле в определении две ошибки, вы можете указать любую.
- Одна из ошибок совсем очевидная (да и вторая, в общем-то, то же), и то, что требуется указать, как исправление, может быть кажется вам само собой разумеющимся. Т.е., если вы придумали ответ на эту задачу, но он кажется вам слишком простым - выкладывайте его в систему, очень может быть это как раз то, что имеется в виду.
Зачтено	

2016-12-07 09:30:00
36	6	Приведите пример лямбда выражения, вычисление которого дает разные результаты при нормальном и аппликативном порядке применения редукций.

Замечания:
- Это простая задача (если понимать все иностранные слова в ее формулировке:)
- Тут, естественно не надо писать никакой программы, надо просто написать пример.	Зачтено	

2016-12-07 09:30:00
36	7	Описать функцию isPower3 с параметром n, которая возвращает True, если n – степень 3 и False, если нет. 

Дополнительное условие:
- Функцию надо описать с помощью нерекурсивной функции и функции fix (комбинатора неподвижной точки) 

Пример вызова:
isPower3 27
Результат должен быть равен True

Замечание:
- Функцию fix опишите, пожалуйста, в своей программе так же, как в слайдах. Или вы можете подключить библиотеку Data.Function, там она определена.
Зачтено	

2016-12-07 09:30:00
35	1	*Доп. задача на C# - до 12.12*

В этот раз задача наверное не очень полезная и не очень осмысленная:( Ну, рассматривайте ее, пожалуйста, просто как техническое упражнение (и как возможность заработать баллы:)

Задание простое: написать функцию fact_cps, которая вычисляет факториал, с использованием рекурсии и continuation passing style. Ну и привести пример вызова - ввести целое число и, с помощью вызова fact_cps напечатать результат.

Т.е., фактически, надо просто переписать пример с занятий на C# (или, если хотите, на любой другой `обычный` язык программирования).	Зачтено	

2016-12-13 00:05:00
34	1	*Доп задача до начала занятия 7.12 (обратите внимание, необычный срок)*

Для типа Expr написать функцию simplify. Эта функция должна упрощать выражение, используя только два очень простых правила:

выражение * 1 = выражение
и
1 * выражение = выражение

Пример вызова:

simplify (Add (Mult X (Num 1)) X)

Должно получиться:
Add X X

Замечание:
- В этой задаче используется Expr с одной переменной, с прошлого занятия 
- Чтобы было немного сложнее, в этой задаче в тестах вы не увидете выражения, не котором этот тест проверяет. Подумайте сами, какие при упрощении могут быть более сложные случаи?
- Не забудьте написать deriving Show (а может вам потребуется и deriving Eq)
Зачтено	

2016-12-07 09:30:00
34	2	*Доп задача до начала занятия 7.12 (обратите внимание, необычный срок*

Реализовать функцию dec, которая вычитает 1 из числа Черча.

Пример вызова: 
dec (\ f x -> f (f (f x))) 
должен вернуть \ f x -> f (f x). 

Для проверки имеет смысл вызвать так:
toInt (dec (\ f x -> f (f (f x)))) 
и ответ д.б. равен 2.

Замечания:
- Для того, чтобы тесты прошли, опишите, пожалуйста, в программе функцияю toInt
- Имеется в виду, что в этой задаче нельзя использовать встроенные функции и вообще нельзя использовать настоящие целые числа (потому что глобальная задача - показать, что встроенные целые числа теоретически не очень нужны, их можно моделировать). Например, нельзя перевести число Черча в обычное, вычесть 1 и перевести обратно.
- Но можно, если хотите, использовать пары! Это подсказка, используя пары это можно написать относительно просто. А в следующий раз мы обсудим, как с этим справился Клини, у которого пар не было, и это будет еще одна доп. задача.
- Вот тут есть подсказка: http://msimuni.wikidot.com/fp-cleene-hint
Как обычно, если вы ее прочтете, и она вам поможет, напишите в комментарии пожалуйста.
- Если подсказка не поможет, но решить задачу хочется, напишите, попробую еще подсказать.
Зачтено	

2016-12-07 09:30:00
33	1	Пусть мы описали функцию find вот так:

find cond (x:xs) = if cond x then (x, xs) else find cond xs

(В этом задании мы не думаем о том, что будет, если мы ничего не найдем. Тут мы считаем, что всегда все находим).

Т.е. у нас есть функции, которые возвращают пару из какого-то значения и хвоста списка. Мы бы хотели написать оператор, немного похожий на оператор композиции (.), Но только чтобы он сначала вызывал одну функцию, а потом вторую функцию вызывал для хвоста, полученного в результате первого вызова.

Задача: Определить такой оператор, назовем его >>>, чтобы можно было писать так:

f = find (>3) >>> find (>3) 
-- f - это функция, которая ищет в списке второй элемент, больший 3.
f [1, 3, 5, 2, 20, 25, 2]
-- Должно получиться (20, [25, 2])

Замечание: 
- В текст задачи включите, пожалуйста, определение find из условия. Иначе тесты не пройдут.
Зачтено	

2016-11-30 09:30:00
33	2	У функции >>> из предыдущего задания есть принципиальный недостаток - она никак не использует результат, найденный первой функцией - только хвост. 

В результате, такие задачи, например с ее помощью записать не удастся:
- Найти в списке элемент x, больший 3, а потом первый элемент, больший x.
или
- Найти в списке элемент x, больший 3, а потом первый элемент y, меньший x, а потом первый элемент, не равный сумме x и у

Какую бы написать функцию, чтобы решить эту проблему?

Опишите какой-то оператор, который как-то дозволяет это делать.

Примера вызова не будет, потому что оператор вы должны придумать сами, но по идее что-то такое

f = find (>3) ... какие-то заклинания ... find (>x) 

И потом:
f [1,6,5,7,1,2]
должно вернуться (7, [1,2])

Замечания:
- На занятии мы еще говорили про функцию, которая возвращает сумму двух найденных чисел, но про это давайте мы решим задачу в следующий раз.
- Ответ очень короткий (почти не длиннее чем решение для >>>), надо только понять, что бы тут хотелось иметь.
- Подсказка: я бы назвал нужную нам функцию >>>=. (Я бы еще лучше назвал ее >>=, но, как вы знаете, потребуется много дополнительных заклинаний..)
- Если вам не придумать решение, напоминающее >>=, вы можете предложить любое другое. Все, что будет немного похоже на решение, я зачту:)
- Если будут трудности, напишите мне, пожалуйста, примерно, в чем они. Я тогда добавлю какую-нибудь подсказку, как на прошлом занятии.

PS Так вышло, что я точно знаю, что у некоторых участников есть решение этой задачи, видимо с прошлых курсов. Я не могу запретить его смотреть, но, еще раз, предложил бы вам попробовать что то придумать самостоятельно. Так интереснее. Если что, лучше попросите подсказку (см. предыдущий пункт) 
Зачтено	

2016-11-30 09:30:00
33	3	Опишите функцию sumDigitsCps, которая ищет сумму цифр положительного числа, используя continuation-passing style.

Чтобы вам было проще, вот обычное решение этой задачи. 
sumDigits n = 
.........if n < 10 then n
.........else sumDigits (div n 10) + mod n 10
(как обычно, точки тут изображают пробелы). 
А вам надо его переписать в cps стиле. 

Примеры вызова:

sumDigitsCps 123 id 
Результат дб равен 6

sumDigitsCps 123 (^2)
Результат дб равен (1+2+3)^2=36

Дополнительные условия:
- Нельзя определять никакие новые функции, кроме sumDigitsCps.
- Определение sumDigitsCps должно быть tail recursive.
(Эти все условия следуют из того что функция должна использовать continuation passing style, я их выписал просто для тех, кто мб пока не в курсе, что это такое).
Зачтено	

2016-11-30 09:30:00
33	4	а. Описать тип Expr, позволяющий задавать выражения с несколькими переменными. Тип должен позволять задать, например, такое выражение:

Add (Var "x") (Mult (Var "y") (Num 3))

(И это должно соответствовать x+y*3 в обычном языке.) 

б. Описать функцию eval для таких выражений. Ее второй параметр должен быть списком пар (имя переменной, значение переменной).

Пример вызова:

eval (Add (Var "x") (Mult (Var "y") (Num 3))) [("x", 5), ("y", 8)]

Результат должен быть равен 29

Замечание:
- Не очень понятно что делать, если для какой-то переменной значение не задано. Вы можете задать любое поведение в этом случае, или вообще не рассматривать такой случай. В тестах такого не будет.	Зачтено	

2016-11-30 09:30:00
33	5	а. К типу Expr добавить еще возможность описывать что-то похожее на let выражения. Вот пример такого выражения

Add (Let "x" (Num 10) (Mult (Var "x") (Var "y"))) (Num 1)

(И это должно соответствовать (let x = 10 in x*y) + 1 в обычном языке.) 

б. Дописать функцию eval из задачи 32-4, чтобы она вычисляла let выражения. 

Пример вызова:

eval (Add (Let "x" (Num 10) (Mult (Var "x") (Var "y"))) (Num 1)) [("y", 2)]

Результат должен быть равен 21	Зачтено	

2016-11-30 09:30:00
33	6	Написать функцию toInt, которая по данному числу Черча возвращает обычное число.

Пример вызова:

toInt (\ f x -> f (f (f x)))

Результат должен быть равен 3.

Замечание: 
- Задача очень простая, пишется в одну строку.
Зачтено	

2016-11-30 09:30:00
33	7	Написать функцию inc, которая прибавляет 1 к числу Черча.

Например, вызов inc (\ f x -> f (f (f x))) должен вернуть \ f x -> f (f (f (f x))). 

Пример вызова:
toInt (inc (\ f x -> f (f (f x))))
Результат д.б. равен 4.

Замечания: 
- Это тоже очень простая задача.
- Чтобы тесты прошли, надо добавить в текст программы определение toInt из задачи 33-6	Зачтено	

2016-11-30 09:30:00
32	1	*Доп. задача на обычном языке, до 5.12*

a. Написать на C# функцию Find, которая в данном массиве целых чисел ищет элемент, удовлетворяющий данному логическому условию. При этом функция должна использовать failure continuation, чтобы обрабатывать случай, когда ничего не найден.

б. Привести пример, как с помощью Find можно решить пример с занятий: 
"Найти в массиве первое число, большее 1000, а если его нет, то первое число, большее 500, а если и его нет, то первое число большее 100 (а если и его нет, вернуть 0)".

Технические замечания про failure continuation на C# см. тут: 
http://msimuni.wikidot.com/fp-failure-continuation 

Замечания:
- Если хотите, можете решить задачу для List<int> или вообще для IEnumerable<int> - как вам удобнее.
- Эта задача, на самом деле, очень простая, надо только понять, о чем вообще речь.
Зачтено	

2016-12-06 00:05:00
30	1	а. Описать функцию find с двумя параметрами - условие (логическая функция) и список. Функция должна искать первый элемент в списка, удовлетворяющий условию, и возвращать Just элемент или Nothing, если ничего не найдено. 

Примеры вызова find:

find (>6) [1, 2, 8, 3]
Результат должен быть Just 8

find (>6) [1, 2, 5, 3]
Результат должен быть Nothing

б. С помощью этого варианта find описать функцию f, которая делает вот что:
В данном списке f ищет:
- первое число, меньшее 5
- первое число, большее 10
- первое число, не равное 7
и возвращает:
- если хотя бы один поиск был неудачным, возвращает Nothing
- если все числа найдены, возвращает Just для их суммы.

Дополнительное условие:
Обязательно надо использовать конструкцию do (как это можно сделать, мы обсуждали на последнем занятии).

Примеры вызова:

f [7, 6, 4, 3, 20, 15, 9] 
Результат должен быть равен Just 30, потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30

f [7, 6, 4, 3, 9]
Результат должен быть равен Nothing, потому что один из трех поисков ничего не находит.

Замечание: 
- Это очень, очень простое упражнение, все решение есть в слайдах.. Просто балл в подарок :)	Зачтено	

2016-11-23 09:30:00
30	3	Пусть мы работаем с функциями, которые возвращает пару (ответ, цена) ('функции тридевятого царства'). Напомню, вот примеры функций, которые там пишут:
sin39 x = (sin x, 2)
exp39 x = (exp x, 5)
и т.д.

Описать операторы >>>= и return1, которые можно вызывать вот так: 
f x = 
sin39 x >>>= \y ->
exp39 x >>>= \z ->
return1 (y+z)
И получиться функция, которая возвращает результат и общую цену.

То есть, например, f 1 должно вернуть (sin 1 + exp 1, 7) 

Замечания:
- Тут, мне кажется, надо начать с того, что понять, какие типы у >>>= и return1. Что они берут на вход и что возвращают? После этого все вроде бы довольно просто. 
- Вот тут есть подсказки по этой задаче, даже несколько http://msimuni.wikidot.com/fp-monad39-hint1. Пользуйтесь) Только пожалуйста, напишите в комментариях в тексте задачи, сколько подсказок вам потребовалось.
Зачтено	

2016-11-23 09:30:00
29	1	*Доп.задача на C# до 28.11*

В этот раз задача с довольно свободным условием, и совсем не сложная.
а. Определите на C# (или на вашем любимом обычном языке) тип или класс, позволяющий описывать двоичные деревья, с вершинами, содержащими целые числа.
б. Определите функцию или метод Find, который для данного дерева и для данного условия (логической функции) ищет в дереве элемент, удовлетворяющий условию, и возвращает его. Если таких элементов несколько, вы можете вернуть любой, который вам удобнее.
в. Если в дереве нет таких элементов, функция должна об этом сообщить, причем так, чтобы в программе можно было понять, нашли мы что-то или нет. (Вывод сообщения на консоль, например, тут не подойдет).
г. Приведите два примера вызова Find, один успешный, который что-то находит, и другой не успешный.

Если что то непонятно, или если захотите что-то уточнить по условию - пишите.	Зачтено	

2016-11-29 00:05:00
27	1	Определите тип Rat для представления дробей. Конструктор этого типа должен записываться так: Rat <числитель> <знаменатель>.
Для этого типа: 
a. Определите оператор + (сложение дробей)
b. Определите оператор == (сравнение дробей на равенство)
с. Определите оператор < (сравнение дробей)

Примеры вызова:

Rat 1 2 + Rat 1 7
Должно быть напечатано
Rat 9 14

Rat 1 3 == Rat 4 5
Результат должен быть равен False

Rat 1 3 < Rat 4 5
Результат должен быть равен True

Замечания:
- Надо ли сокращать дроби? Например, что будет, если сложить Rat 1 3 и Rat 1 6? 
Ответ: Как хотите, не обязательно сокращать. В тестах таких примеров не будет.
- Не забудьте в определении Rat написать deriving Show. Без этого тесты не пройдут.
Зачтено	

2016-11-16 09:30:00
24	1	*Простое упражнение про >>= и do нотацию*

Опишите две функции pow1 и pow2. Обе должны для данного n возвращать список:

[1, 
1, 2^2, 
1, 2^2, 3^3,
...
1, 2^2, 3^3, ..., n^n]

То есть, должен получиться список, в котором 1+2+...+n элементов.

Дополнительные условия:
- pow1 надо написать с помощью оператора >>= и функции return
- pow2 надо написать с помощью do нотации
- в обеих задачах нельзя использовать стандартные функции, кроме >>=, return и арифметики. А во второй задаче и >>= нельзя использовать, только do и return.

Примеры вызова:

pow1 3
pow2 3

В обоих случаях должно получиться:
[1,1,4,1,4,27]
Зачтено	

2016-11-09 09:30:00
24	2	*Maybe рыбка*

В компании X так заботятся о надежности, что приняли решение: все функции должны возвращать не просто значение, а Maybe, то есть Just значение или Nothing. Вот примеры таких функций:

f i = if i > 0 then Just (-i) else Nothing
g i = if mod i 2 == 0 then Just (div i 2) else Nothing

Описать оператор <=< который работает так же, как оператор . (композиция функций), но только для таких функций, возвращающих Maybe.

То есть, надо определить <=<, чтобы f <=< g задавал функцию, которая сначала вызывает g, и потом, для ответа, вызывает f. И при этом, если одна из функций вернула Nothing, то и ответ будет Nothing.

Примеры вызова:
Если определены описанные выше функции, и потом мы написали
h = f <=< g
,то:
h 10 должно возвращать Just (-5)
h (-10) должно возвращать Nothing
h 9 должно возвращать Nothing и вообще не вызвать f
Зачтено	

2016-11-09 09:30:00
21	1	При помощи оператора >>= для списков описать функцию tripleOdd, которая в данном списке все нечетные числа повторяет три раза, а остальные оставляет, как есть.

Пример вызова:

tripleOdd [1, 2, 6, 3]

Должно получиться:
[1,1,1,2,6,3,3,3]	Зачтено	

2016-11-02 09:30:00
18	1	Описать функцию bigCos c параметром x, которая возвращает первый элемент в последовательности cos 1, cos 2, cos 3, cos 4, ... , который больше или равен x. 

Дополнительное условие: нельзя определять свои функции (кроме bigCos, конечно). Можно использовать любые стандартные функции и лямбда выражения. 

Пример вызова: 
bigCos 0.99 результат должен быть равен примерно 0.9912028 

Замечания:
- очевидная подсказка: тут, конечно, удобно использовать бесконечные списки. Но можно и без них, наверное.	Зачтено	

2016-11-02 09:30:00
18	2	Пусть в списке я записал последовательность чисел - сколько денег я тратил каждый день в этом году. Запись я начал, конечно же, с понедельника.
Кроме этого я дал себе слово - по будним дням тратить не больше 300 р в день, а по выходным - не больше 1000 р. в день.
Опишите функцию checkMyRules у которой параметр - такой список расходов, и которая проверяет, выполнил ли я свои собственные правила. 

Примеры вызова: 
checkMyRules [100,200,150,250,100,200,800,100,300,200] 
Ответ должен быть равен True. 
checkMyRules [100,200,150,250,100,200,800,100,600,200] 
Ответ должен быть равен False, потому что во второй вторник я потратил больше 200 р. 

Замечание:
- В этой задаче можно (но не обязательно) использовать зацикленный список
Зачтено	

2016-11-02 09:30:00
18	3	Опишите brackets, как бесконечный список из строк, вот такой: ["[]","[[]]","[[[]]]","[[[[]]]]"...]

Дополнительное условие: В этой задаче обязательно надо использовать прием "завязывание в узел"

Пример вызова:
take 4 brackets
Результат должен быть равен ["[]","[[]]","[[[]]]","[[[[]]]]"]

Напоминание: строки в Haskell - это списки символов. То есть, к ним можно применять операции :, ++ и другие функции для списков.
Зачтено	

2016-11-02 09:30:00
18	4	*Еще одна задача про тридевятое царство*

1. Описать оператор <=< который работает так же, как оператор . (композиция функций), но только для функций, которые возвращают пару (результат, цена).
Например, если у нас есть функции
sin39 x = (sin x, 2)
cos39 x = (cos x, 3)
и потом мы напишем
f = cos39 <=< sin39
то f должна для x возвращать пару (cos(sin x),5)

2. Описать функцию calculate из задачи 15-4 с помощью foldr и оператора <=<

Подсказка: определение, скорее всего, будет выглядеть как-то так:
calculate fs = foldr (<=<) ...какая то функция.. fs

Замечание: В определении calсulate приведенном выше, в принципе можно не писать слева и справа fs (потому что работает карринг). Но в системе тестирования есть, видимо, некоторая проблема, из за которой без fs тесты не пройдут ( Те пишите тут fs.

Примеры вызова:
let { f x = (2*x, 1); g = f <=< а } in g 10
Результат должен быть равен (40,2)
let f x = (2*x,1) in calculate [f,f,f] 1
Результат должен быть равен (8,3)
Зачтено	

2016-11-02 09:30:00
17	1	*Доп.задача до 31.10* 
Используя метод Select в C# (или соответствующий аналог map в вашем "обычном" языке), напишите функцию ZeroDigits с двумя параметрами a (массив целых положительных чисел), n (целое положительное число). Эта функция должна во всех элементах массива a заменить последние n цифр на 0 и вернуть полученный новый массив. Например, если в массиве числа, 563, 5643, 76796, то после вызова ZeroDigits(a, 2) должен вернуться массив из чисел 500, 5600, 76700

Замечания:
- если в числе меньше n цифр, то его надо заменить на 0
- вместо массива можно использовать List, как вам удобнее	Зачтено	

2016-11-01 00:05:00
16	2	*Доп. задача, до 29.10* 
Описать бесконечный список cantor , содержащий все пары целых положительных чисел (каждую по одному разу). 

Пример вызова: 
take 100 cantor 
Что получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, но, например, что-то вроде [(1,1), (1,2), (2,2), (2,1), (1,3) и т.д.	Зачтено	

2016-10-30 00:05:00
15	1	Опишите переменную fives, как бесконечный список [5,55,555,5555,...] – т.е. список из целых положительных чисел, у которых все цифры равны 5.

Пример вызова: 
take 7 fives 
Ответ должен быть равен [5,55,555,5555,55555,555555,5555555]	Зачтено	

2016-10-19 09:30:00
15	2	Используя функцию foldTree с последнего занятия (тот вариант, который катаморфизм, в котором у f три параметра), опишите функцию sumOdd. У этой функции параметр - дерево, и она должна вычислять сумму всех нечетных чисел в этом дереве. 

Пример вызова: 
sumOdd (Node 3 (Node 2 Empty Empty) (Node 5 Empty Empty)) 
Ответ должен быть равен 8

Замечания:
- эту задачу можно, конечно. решить с помощью любого варианта foldTree, но вы решите его, пожалуйста, именно с помощью катаморфизма.
- сам код foldTree тоже надо включить в текст программы, иначе тесты не пройдут. Его можно скопировать из слайдов.
Зачтено	

2016-10-19 09:30:00
15	4	*Задача про тридевятое царство*
В тридевятом царстве жизнь так устроена, что за все надо платить.. Поэтому, в частности, все функции имеют свою цену. И поэтому в тридевятом царстве не бывает, чтобы функция возвращала число, она всегда возвращает пару (ответ, цена). Вот примеры функций, которые там пишут:
sin39 x = (sin x, 2)
exp39 x = (exp x, 5)
f x = (x*x+5, 10)

Напишите функцию calculate, которая берет на вход список таких функций и число, вызывает все эти функции справа налево и возвращает пару (итоговое значение, итоговая цена).

Пример вызова:
calculate [sin39,exp39,f] 1
Результат должен быть равен (sin(exp(1*1+5)), 17)

Замечание:
- Надо описать только calculate, функции типа sin39 и т.д. описывать не надо, я их сам опишу в тестах. (Но конечно, вы должны будете их описать, если хотите сами потестировать решение).
Зачтено	

2016-10-19 09:30:00
14	1	*Доп.задача на обычном языке, до 24.10*

Аналогом map в C# является, видимо, метод Select, а аналогом filter - метод Where (это части LINQ но их вполне можно использовать и просто как удобные методы). См. простые примеры вызова этих методов тут: http://msimuni.wikidot.com/fp-select-where 

С помощью Select и Where опишите функцию, которая:
- берет в качестве параметра массив целых положительных чисел
- возвращает массив из последних цифр всех чисел из исходного массива, которые сами делятся на 3, а их последняя цифра не делится на 3.Например, если входной массив содержит числа 114, 14, 13, 81, 33, 30, 1011, то надо вернуть массив из чисел 4,1,1 (это последние цифры чисел 114, 81, 1011). 

Замечания:
- Конечно, в этой задаче нет особого смысла, это просто несложное упражнение на вызов Select и Where.
- Как обычно, если вы пишете на другом обычном языке, то в нем должны быть аналоги map и filter (или, если их нет, но хочется использовать именно этот язык, вы можете сами написать такие аналоги)

Зачтено	

2016-10-25 00:05:00
13	1	Описать функцию digitsToNum, которая по данному списку целых чисел (все эти числа от 0 до 9) возвращает число, состоящее из таких цифр.

Пример вызова:
digitsToNum [1,2,3,4] - результат должен быть равен 1234

Дополнительные условие:
- в этой задаче нельзя использовать рекурсию
- из стандартных функций можно использовать _только_ foldr (именно foldr, с foldl то все совсем просто)
- еще, конечно, можно использовать арифметические операторы и, если хотите, функции работы с парами (это, кстати, подсказка))	Зачтено	

2016-10-23 00:05:00
13	3	На занятии мы говорили. что не все электрические схемы можно представить с помощью последовательных и параллельных соединений. Приведите пример такой схемы.

Замечания:
- Ответом должен быть рисунок схемы. Поскольку к сожалению, система тестирования пока не позволяет загружать рисунки, вы можете или как-то нарисовать схему с помощью символов (например, -, | и тд.), или выложить ссылку на картинку.
- Или вы можете прислать мне картинку в письме. Тогда в систему выложите, пожалуйста, любую строчку, вроде "Решение послано по почте". Без этого я не могу зачесть задачу в системе.
- На всякий случай, давайте уточним условие. Схема должна: а. состоять только из проводов и резисторов, б. иметь один вход и один выход. И при этом ее должно быть невозможно описать, как последовательность операций "соединить две схемы последовательно" и "соединить две схемы параллельно".	Зачтено	

2016-10-23 00:05:00
12	1	"Крестик"
Описать функцию cross, которая для данного числа n возвращает список списков, представляющий матрицу, в которой на главной и побочной диагоналях стоят 1, а все остальные элементы равны 0.

Примеры вызова:
cross 4
Результат должен быть равен:
[[1,0,0,1],
[0,1,1,0],
[0,1,1,0],
[1,0,0,1]]

cross 5
Результат должен быть равен:
[[1,0,0,0,1],
[0,1,0,1,0],
[0,0,1,0,0],
[0,1,0,1,0],
[1,0,0,0,1]]
Зачтено	

2016-10-12 09:30:00
12	4	Пусть мы хотим описывать в программе на Хаскеле электрические схемы. Мы считаем, что электрическая схема - это:
- или сопротивление, тогда известно его величина в омах
- или две схемы, соединенных параллельно - или две схемы, соединенных последовательно (На самом деле есть схемы, которые таким способом не описать, ну и ладно..) 

1. Опишите тип (data) Scheme, который позволяет описывать такие схемы. 
2. Опишите функцию totalResistance, у которой один параметр - схема, и которая возвращает значение общего сопротивления для этой схемы. Например, для двух сопротивлений 4 Ом, соединенных последовательно, функция должна возвращать 8, а для двух сопротивлений 4 Ом, соединенных параллельно, функция должна возвращать 2. 

Замечания:
- Для того, чтобы хоть как протестировать программу, включите, пожалуйста в вашу программу такое определение test
test = totalResistance ...описание схемы,состоящей из двух сопротивлений 2 Ом соединенных параллельно, к которым присоединено еще одно сопротивление 2 Ом последовательно...
То есть, значение test должно в результате вычислиться равным 3. 
- Если вы забыли, как считать общее сопротивление схемы - напишите, я подскажу :)
Зачтено	

2016-10-12 09:30:00
11	1	*Простая задача про карринг на C#. Дополнительная, до 17.10*

Вступительная история:

Пусть у нас есть знакомый программист Василий, которому часто надо для списков целых положительных чисел проверять, верно ли, что все они содержат какую-то данную цифру. Т.е. типичная задача Василия - что-то вроде:
Проверить, верно ли что в массиве a все числа содержат хотя бы одну цифру 7.

Василий написал вспомогательную функцию CheckDigit c параметрами d - цифра, которую мы ищем и i - целое число. И вызывает ее как-то так:

bool b = a.All(i => CheckDigit(7, i));

Но однажды у нему пришел его друг, функциональный программист Петр, и сказал: ты же можешь воспользоваться каррингом! И написать функцию CheckDigitCurried, которую можно вызывать как-то так:

bool b = a.All(CheckDigitCurried(7));

Т.е. будет немного короче. А если потребуется проверить одно конкретное число, ее можно будет вызвать как-то так:

bool b = CheckDigitCurried(7)(n); // Проверить , есть ли в числe n цифра 7

Задача:
Помогите Василию, и напишите функцию CheckDigitCurried, которую можно так вызывать. 

Замечания:
- Как обычно, эту задачу можно написать на любом обычном языке 
- Если писать на C#, то, обратите внимание, м.б. удобно использовать т.н. statement lambda, которые записываются так:

параметр => { последовательность операторов, содержащая return }

- Если условие не очень понятно - пишите, я поясню.
Зачтено	

2016-10-18 00:05:00
9	1	Описать функцию multTable, которая для данного числа n возвращает список списков, представляющий таблицу умножения чисел от 1 до n.

Пример вызова:
multTable 4
Результат должен быть равен:
[[1,2,3,4],
[2,4,6,8],
[3,6,9,12],
[4,8,12,16]]	Зачтено	

2016-10-05 09:30:00
9	2	Опишите две функции, countEven и countEven1, которые для данного списка вычисляют количество четных чисел в этом списке. (Т.е. надо написать две версии одной функции).

Дополнительные условия:
- В функции countEven можно использовать _только_ стандартную функцию foldr. Точнее, можно, конечно, использовать функцию mod, но нельзя использовать map, filter и т.д. Можно (но особо не нужно) задавать свои нерекурсивные функции. Можно, конечно, использовать лямбда-выражения.

- В функции countEven1 можно использовать любые стандартные функции, кроме foldr и foldl (в частности map и filter), и тоже, если надо, можно использовать свои нерекурсивные функции и лямбда-выражения. Но _нельзя_ определять свои рекурсивные функции.

Примеры вызова:
countEven [4, 3, 14, 8, 5, 33, 6]
countEven1 [4, 3, 14, 8, 5, 33, 6]
Ответ должен быть равен 4
Зачтено	

2016-10-05 09:30:00
9	3	Опишите функцию myfoldl, которая делает точно то же, что и стандартная функция foldl (т.е. сворачивает все элементы слева направо).

Пример вызова:
myfoldl (+) 0 [1,2,3]
Функция должна вычислить ((0+1)+2)+3, причем вычисления должны происходить именно в таком порядке.

Замечания:
- нельзя, конечно, использовать стандартный foldl
- можно посмотреть определение foldl и переписать, но, конечно, я бы советовал попробовать придумать самостоятельно, это интереснее.	Зачтено	

2016-10-05 09:30:00
9	4	*Снова задача 6.5, но с доп.условием*

Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).
Пример вызова:

f = repeatFunc sin 3

должно определить f x = sin (sin (sin x))
и после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.

Дополнительные условия: 
- задачу надо написать, используя стандартные функции, без рекурсии.
- можно определять свои функции, но они должны быть не рекурсивными

Замечание:
- если вы уже посылали такое решение, проcто пошлите его еще раз.
Зачтено	

2016-10-05 09:30:00
6	1	Опишите функцию isosc (от слова isosceles - равнобедренный), у которой три параметра - пары целых чисел, и которая возвращает True, если соответствующие точки на плоскости задают равнобедренный треугольник, а иначе False.

Примеры вызова:
isosc (0, 2) (2, 0) (2,2)
- результат должен быть равен True
isosc (-3, 2) (2, 0) (2,2)
- результат должен быть равен False	Зачтено	

2016-09-28 09:30:00
6	2	Определить функцию sumprod, которая вычисляет сумму произведений всех пар стоящих рядом элементов.

Пример вызова:
sumprod [1,3,2,7]
Ответ должен быть равен 1*3+3*2+2*7 = 23.

Дополнительное условие: Задачу надо написать, используя стандартные функции, без рекурсии.

Замечание:
- Если нужна подсказка, ее можно посмотреть на сайте, вот тут: http://msimuni.wikidot.com/hint-minsum 
- Если вы такое решение уже посылали для задачи 3-2, просто пошлите его еще раз, пожалуйста.	Зачтено	

2016-09-28 09:30:00
6	3	Описать функцию height, которая ищет высоту данного дерева. 

Замечание 1: В задаче вы сначала должны описать data для дерева. И его надо описать точно так же, как на занятии (можно или простое или полиморфное определение, как хотите). Извините за ограничение вашей творческой свободы, но это, понятно, ограничение системы тестирования..

Замечание 2: С чего начинать считать, чему равна высота дерева, в котором только одна вершина, у которой нет потомков? Иногда считают, что у такого дерева высота 1, иногда считают, что 0. Давайте для определенности считать, что у такого дерева высота 0.

Примеры вызова:
height (Node 1 Empty Empty)
Ответ должен быть 0
height (Node 1 (Node 1 Empty Empty) Empty)
Ответ должен быть 1 
Зачтено	

2016-09-28 09:30:00
6	4	Пусть в нашей программе мы хотим хранить информацию о товарах в кондитерском магазине. Товары могут быть:
- или тортами, и тогда мы храним их название, и цену (Например, "Санчо" 321)
- или упаковками конфет, и тогда мы храним их название, цену за килограмм, и вес упаковки в кг. (например, "Белочка" 771 0.25).

а. Опишите тип данных Candy, позволяющий хранить такую информацию.

б. Опишите функцию totalPrice, которая для данного списка товаров возвращает общую цену всех товаров в списке.

в. Чтобы было хоть какое-то тестирование, пожалуйста, включите в решение пример вызова totalPrice, который в результате дает 1000. И назовите его test. Т.е. что-то вроде:

test = totalPrice ...какой-то список из товаров разных видов...

и результат должен быть равен 1000.

Замечание:
Обратите, пожалуйста внимание, цена для тортов и упаковок конфет вычисляется по разному. Для конфет она зависит еще и от веса.
Зачтено	

2016-09-28 09:30:00
6	5	Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).
Пример вызова:

f = repeatFunc sin 3

должно определить f x = sin (sin (sin x))
и после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.

Замечание: Вообще это несложная задача, но, подозреваю, может показаться сложной, просто тема не совсем обычная. Если что то с ней непонятно, или вообще ничего непонятно - можете написать, я постараюсь что-нибудь подсказать.
Зачтено	

2016-09-28 09:30:00
5	1	*Доп. задача до 3.10 включительно*
Очень простая функция высшего порядка на C#

Написать на C# функцию (статический метод) Integral, которая позволяет вычислять определенный интеграл на данном интервале. У нее должны быть быть 3 параметра:
- f - функция (статический метод или лямбда выражение) 
- a, b - пределы интегрирования.
Пример вызова:

double result = Integral(x => x*x, 0, 1);

Метод интегрирования можно взять любым, самым простым. Например, разбить отрезок на 100 равных частей и использовать метод прямоугольников или метод трапеций.

Замечания:
- Пример похожей программы есть вот тут: http://msimuni.wikidot.com/fp-commonlang
- Там же разные замечания про то, зачем эти задачки про "обычные" языки, как их сдавать и т.д. 
- Если хотите, можете сделать задачу на С++ или на каком-нибудь другом "обычном" языке. Если есть сомнения, подойдет ли тот или иной язык, пишите.	Зачтено	

2016-10-04 00:05:00
4	1	*Доп. задача до 2.10 включительно*
Описать функцию upDown, которая проверяет, верно ли, что в данном списке сначала строго возрастают, а потом, с какого-то момента, строго убывают.

Примеры вызова:
upDown [2, 6, 9, 7, 3, 1]
- должна вернуть True
upDown [2, 6, 9, 7, 3, 1, 8]
- должна вернуть False, потому что числа возрастают, убывают и потом снова возрастают.
upDown [2, 6, 9]
- должна вернуть False, потому что числа только возрастают

Уточнение:
М.б. лучше четко сформулировать, что это значит "сначала возрастают, потом убывают". Имеется в виду, что, если взять все пары стоящих рядом чисел и сравнить числа в парах, то сначала насколько раз (по крайней мере один раз) первое число будет меньше, а потом несколько раз (тоже по крайней мере один раз) первое число будет больше.
Зачтено	

2016-10-03 00:05:00
3	1	Описать функцию minlist, которая ищет минимальный элемент в данном списке.

Пример вызова:
minlist [3,2,7]
Ответ должен быть равен 2.

Замечание: На самом деле, конечно, в Хаскеле есть такая стандартная функция (называется minimum), но, пожалуйста, в этой задаче вы ее не используйте.	Зачтено	

2016-09-21 09:30:00
3	2	Описать функцию sumprod, которая для списка [x1,x2,x3,x4,...,xn] ищет значение x1*x2+x2*x3+x3*x4+.... То есть, сумму произведений всех пар стоящих рядом элементов.

Пример вызова:
sumprod [1,3,2,7]
Ответ должен быть равен 1*3+3*2+2*7 = 23.

Замечание: Можно считать, что мы точно знаем, что в списке есть хотя бы два элемента.
Зачтено	

2016-09-21 09:30:00
3	4	Описать функцию sameDigits, которая возвращает True, если в списке есть два элемента, у которых совпадают последние цифры.

Примеры вызова:
sameDigits [13,2,73]
Ответ должен быть равен True, потому что у 13 и 73 одинаковые последние цифры.
sameDigits [13,2,79,5]
Ответ должен быть равен False.
Зачтено	

2016-09-21 09:30:00
1	1	Описать функцию f n, которая вычисляет 
1+1/(1+1/(1+ ...+1/1)) - n дробей

Пример вызова:
f 3
Должно получиться 1+1/(1+1/(1+1/1)), то есть 1.6666.. 
Зачтено	

2016-09-14 09:30:00
1	2	Описать функцию b n, которая вычисляет 
0+1/(1+1/(2+1/(3+ ...+1/n))) - n дробей

Пример вызова:
b 3
Должно получиться 0+1/(1+1/(2+1/3)), то есть 0.7	Зачтено	

2016-09-14 09:30:00
1	3	Описать функцию 
sumsqr n = (1+2+...+n)^2/(1^2 + 2^2 + ... + n^2))

Напоминание: ^ - это операция возведения в степень.

Дополнительное условие: В этой задаче, пожалуйста, обязательно используйте хвостовую рекурсию и накапливающие параметры.

Пример вызова:
sumsqr 2 
Должно получиться 1.8

Зачтено	

2016-09-14 09:30:00
1	4	Описать функцию sumfact n: 
sumfact n = 1!+2!+...+n!
В решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.

Пример вызова:
sumfact 3
Результат должен быть равен 9.	Зачтено	

2016-09-14 09:30:00
