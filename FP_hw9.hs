{-9.1
Описать функцию multTable, которая для данного числа n возвращает список списков, 
представляющий таблицу умножения чисел от 1 до n.

Пример вызова:
multTable 4
Результат должен быть равен:
[[1,2,3,4],
[2,4,6,8],
[3,6,9,12],
[4,8,12,16]] -}


multTable n = map (\i -> map (\j -> i*j) [1..n]) [1..n]


{-9.2
Опишите две функции, countEven и countEven1, которые для данного списка вычисляют 
количество четных чисел в этом списке. (Т.е. надо написать две версии одной функции).

Дополнительные условия:
- В функции countEven можно использовать _только_ стандартную функцию foldr. 
Точнее, можно, конечно, использовать функцию mod, 
но нельзя использовать map, filter и т.д. 
Можно (но особо не нужно) задавать свои нерекурсивные функции. 
Можно, конечно, использовать лямбда-выражения.

- В функции countEven1 можно использовать любые стандартные функции, 
кроме foldr и foldl (в частности map и filter), и тоже, если надо, 
можно использовать свои нерекурсивные функции и лямбда-выражения. 
Но _нельзя_ определять свои рекурсивные функции.

Примеры вызова:
countEven [4, 3, 14, 8, 5, 33, 6]
countEven1 [4, 3, 14, 8, 5, 33, 6]
Ответ должен быть равен 4-}

countEven xs = foldr (\x counter -> 
                            if mod x 2 == 0 
                            then counter + 1 
                            else counter) 0 xs

countEven1 xs = length (filter (\x -> mod x 2 == 0 ) xs)

{-9.3
Опишите функцию myfoldl, которая делает точно то же, что и стандартная функция foldl 
(т.е. сворачивает все элементы слева направо).

Пример вызова:
myfoldl (+) 0 [1,2,3]
Функция должна вычислить ((0+1)+2)+3, причем вычисления должны происходить 
именно в таком порядке.

Замечания:
- нельзя, конечно, использовать стандартный foldl
- можно посмотреть определение foldl и переписать, но, конечно, 
я бы советовал попробовать придумать самостоятельно, это интереснее.-}

myfoldl f e [] = e
myfoldl f e (x:xs) = myfoldl f (e `f` x) xs


{-9.4
*Снова задача 6.5, но с доп.условием*

Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f 
(т.е. композицию функции с самой собой n раз).
Пример вызова:

f = repeatFunc sin 3

должно определить f x = sin (sin (sin x))
и после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.

Дополнительные условия: 
- задачу надо написать, используя стандартные функции, без рекурсии.
- можно определять свои функции, но они должны быть не рекурсивными

Замечание:
- если вы уже посылали такое решение, проcто пошлите его еще раз.-}

repeatFunc f n = foldr (.) id $ replicate n f



