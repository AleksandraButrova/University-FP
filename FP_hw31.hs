{--31.1
Немного информации:
В Хаскеле есть еще стандартный класс Foldable. Приведем пример его реализации для нашего типа Tree:

instance Foldable Tree where
    foldr f e Empty = e
    foldr f e (Node v l r) = let
                               res1 = foldr f e l
                               res2 = foldr f res1 r
                             in f v res2

То есть, мы можем для какого-то типа задать что-то похожее для foldr для списков. 
Тоже передается функция с двумя аргументами и начальное значение, и надо 'соединить' все, 
что находится в контейнере с помощью этой функции.

После этого мы можем, например, пользоваться sum, product и многими другими полезными функциями, 
потому что они, на самом деле, определены не для списков, а для класса Foldable.

Задача: Определить наш тип Scheme, как реализацию Foldable.

Примеры вызова:

foldr (+) 0 (S (R 3) (R 5))
Результат должен быть равен 8.

sum (S (R 3) (R 5))
Результат тоже должен быть равен 8.

Замечание: как и для Functor, тип Scheme надо обязательно определить с параметром (data Scheme a = ...), 
иначе будет синтаксическая ошибка.--}

data Scheme s = Value s | 
                Сonsistently (Scheme s) (Scheme s) |
                Parallel (Scheme s) (Scheme s)

instance Foldable Scheme where


