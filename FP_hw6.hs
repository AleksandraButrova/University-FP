{-- 6.1
Опишите функцию isosc (от слова isosceles - равнобедренный), 
у которой три параметра - пары целых чисел, и которая возвращает True, 
если соответствующие точки на плоскости задают равнобедренный треугольник, 
а иначе False.

Примеры вызова:
isosc (0, 2) (2, 0) (2,2)
- результат должен быть равен True
isosc (-3, 2) (2, 0) (2,2)
- результат должен быть равен False
--}

sideLength (x1, y1) (x2, y2) = sqrt (fromIntegral((x2- x1)^2 + (y2-y1)^2))
isosc (x1, y1) (x2, y2) (x3, y3) =  if  l1 == l2 || l1 == l3 || l2 == l3
                                    then True
                                    else False
                                    where   l1 = sideLength (x1, y1) (x2, y2)
                                            l2 = sideLength (x1, y1) (x3, y3)
                                            l3 = sideLength (x3, y3) (x2, y2)

{--6.2
Определить функцию sumprod, 
которая вычисляет сумму произведений всех пар стоящих рядом элементов.

Пример вызова:
sumprod [1,3,2,7]
Ответ должен быть равен 1*3+3*2+2*7 = 23.

Дополнительное условие: Задачу надо написать, используя стандартные функции, без рекурсии.

Замечание:
- Если нужна подсказка, ее можно посмотреть на сайте, вот тут: http://msimuni.wikidot.com/hint-minsum 
- Если вы такое решение уже посылали для задачи 3-2, просто пошлите его еще раз, пожалуйста.
--}

sumprod (x:xs) = sum (map (\(x, y) -> x*y) (zip (x:xs) xs))


{--6.3
Описать функцию height, которая ищет высоту данного дерева. 

Замечание 1: В задаче вы сначала должны описать data для дерева. 
И его надо описать точно так же, как на занятии (можно или простое или полиморфное определение, 
как хотите). Извините за ограничение вашей творческой свободы, но это, понятно, 
ограничение системы тестирования..

Замечание 2: С чего начинать считать, чему равна высота дерева, в котором только одна вершина, 
у которой нет потомков? Иногда считают, что у такого дерева высота 1, иногда считают, что 0. 
Давайте для определенности считать, что у такого дерева высота 0.

Примеры вызова:
height (Node 1 Empty Empty)
Ответ должен быть 0
height (Node 1 (Node 1 Empty Empty) Empty)
Ответ должен быть 1 
--}

data Tree a = Empty | Node a (Tree a) (Tree a)

height Empty = 0
height (Node a Empty Empty) = 0
height (Node a left right) = 1 + if hleft > hright
                                  then hleft
                                  else hright
						          where hleft = height left
						                hright = height right




{--6.4
Пусть в нашей программе мы хотим хранить информацию о товарах в кондитерском магазине. Товары могут быть:
- или тортами, и тогда мы храним их название, и цену (Например, "Санчо" 321)
- или упаковками конфет, и тогда мы храним их название, цену за килограмм, и вес упаковки в кг. (например, "Белочка" 771 0.25).

а. Опишите тип данных Candy, позволяющий хранить такую информацию.
б. Опишите функцию totalPrice, которая для данного списка товаров возвращает общую цену всех товаров в списке.
в. Чтобы было хоть какое-то тестирование, пожалуйста, включите в решение пример вызова totalPrice, который в результате дает 1000. 
И назовите его test. Т.е. что-то вроде:
test = totalPrice ...какой-то список из товаров разных видов...
и результат должен быть равен 1000.

Замечание:
Обратите, пожалуйста внимание, цена для тортов и упаковок конфет вычисляется по разному. Для конфет она зависит еще и от веса.
--}

data Candy = Cake String Double |
             Chocolate String Double Double

countPrice (Cake name price) = price
countPrice (Chocolate name price weight) = price * weight
totalPrice [] = 0
totalPrice (c:candies) = countPrice c + totalPrice candies

test = totalPrice [Cake "Meow" 200, Chocolate "Woof" 1000 0.8]






{--6.5
Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).
Пример вызова:

f = repeatFunc sin 3

должно определить f x = sin (sin (sin x))
и после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.

Замечание: Вообще это несложная задача, но, подозреваю, может показаться сложной, просто тема не совсем обычная. 
Если что то с ней непонятно, или вообще ничего непонятно - можете написать, я постараюсь что-нибудь подсказать.
--}


repeatFunc f 1 = f
repeatFunc f n = repeatFunc f (n-1) . f