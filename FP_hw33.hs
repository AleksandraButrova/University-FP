{--33.1
Пусть мы описали функцию find вот так:

find cond (x:xs) = if cond x then (x, xs) else find cond xs

(В этом задании мы не думаем о том, что будет, если мы ничего не найдем. Тут мы считаем, что всегда все находим).

Т.е. у нас есть функции, которые возвращают пару из какого-то значения и хвоста списка. 
Мы бы хотели написать оператор, немного похожий на оператор композиции (.), 
Но только чтобы он сначала вызывал одну функцию, а потом вторую функцию вызывал для хвоста, 
полученного в результате первого вызова.

Задача: Определить такой оператор, назовем его >>>, чтобы можно было писать так:

f = find (>3) >>> find (>3) 
-- f - это функция, которая ищет в списке второй элемент, больший 3.
f [1, 3, 5, 2, 20, 25, 2]
-- Должно получиться (20, [25, 2])

Замечание: 
- В текст задачи включите, пожалуйста, определение find из условия. Иначе тесты не пройдут.--}

find cond (x:xs) =
                    if cond x
                    then (x, xs)
                    else find cond xs
                    

infixr 9 >>>
f2 >>> f1 = \x -> let
                   new_list = snd (f1 x)
                   new_res = f2 new_list
                  in new_res--(fst new_res ,snd new_res)

f = find (>3) >>> find (>3)




-------------------------------------------------------------------------------------------------------------------
{--33.2
У функции >>> из предыдущего задания есть принципиальный недостаток - она никак не использует результат, 
найденный первой функцией - только хвост. 

В результате, такие задачи, например с ее помощью записать не удастся:
- Найти в списке элемент x, больший 3, а потом первый элемент, больший x.
или
- Найти в списке элемент x, больший 3, а потом первый элемент y, меньший x, а потом первый элемент, не равный сумме x и у

Какую бы написать функцию, чтобы решить эту проблему?

Опишите какой-то оператор, который как-то дозволяет это делать.

Примера вызова не будет, потому что оператор вы должны придумать сами, но по идее что-то такое

f = find (>3) ... какие-то заклинания ... find (>x) 

И потом:
f [1,6,5,7,1,2]
должно вернуться (7, [1,2]) --}


infixr 9 >>==
f2 >>== f1  = \x -> let
                     pair1 = f1 x
                     pair2 = f2 ( > fst pair1) snd pair1
                    in pair2

test = find >>== find (>3)
    



-------------------------------------------------------------------------------------------------------------------
{--33.3
Опишите функцию sumDigitsCps, которая ищет сумму цифр положительного числа, используя continuation-passing style.

Чтобы вам было проще, вот обычное решение этой задачи. 
sumDigits n = 
.........if n < 10 then n
.........else sumDigits (div n 10) + mod n 10
(как обычно, точки тут изображают пробелы). 
А вам надо его переписать в cps стиле. 

Примеры вызова:

sumDigitsCps 123 id 
Результат дб равен 6

sumDigitsCps 123 (^2)
Результат дб равен (1+2+3)^2=36

Дополнительные условия:
- Нельзя определять никакие новые функции, кроме sumDigitsCps.
- Определение sumDigitsCps должно быть tail recursive.
(Эти все условия следуют из того что функция должна использовать continuation passing style, 
я их выписал просто для тех, кто мб пока не в курсе, что это такое).--}

sumDigitsCps 0 f = f 0
sumDigitsCps n f = sumDigitsCps (div n 10 ) (f.(+ mod n 10))




-------------------------------------------------------------------------------------------------------------------
{--33.4
а. Описать тип Expr, позволяющий задавать выражения с несколькими переменными. Тип должен позволять задать, например, такое выражение:

Add (Var "x") (Mult (Var "y") (Num 3))

(И это должно соответствовать x+y*3 в обычном языке.) 

б. Описать функцию eval для таких выражений. Ее второй параметр должен быть списком пар (имя переменной, значение переменной).

Пример вызова:

eval (Add (Var "x") (Mult (Var "y") (Num 3))) [("x", 5), ("y", 8)]

Результат должен быть равен 29

Замечание:
- Не очень понятно что делать, если для какой-то переменной значение не задано. 
Вы можете задать любое поведение в этом случае, или вообще не рассматривать такой случай. В тестах такого не будет.--}

-- нужен был копипаст и переопределение ниже
-- data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr

-- eval (Num i) values = i
-- eval (Var x) [] = 0
-- eval (Var x) (v:values) = if x == fst v 
--                           then snd v
--                           else eval (Var x) values
-- eval (Add x y) values = eval x values + eval y values
-- eval (Mult x y) values = eval x values * eval y values





-------------------------------------------------------------------------------------------------------------------
{--33.5
а. К типу Expr добавить еще возможность описывать что-то похожее на let выражения. Вот пример такого выражения

Add (Let "x" (Num 10) (Mult (Var "x") (Var "y"))) (Num 1)

(И это должно соответствовать (let x = 10 in x*y) + 1 в обычном языке.) 

б. Дописать функцию eval из задачи 32-4, чтобы она вычисляла let выражения. 

Пример вызова:

eval (Add (Let "x" (Num 10) (Mult (Var "x") (Var "y"))) (Num 1)) [("y", 2)]

Результат должен быть равен 21--}

data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Expr Expr

eval (Num i) values = i
eval (Var x) [] = 0
eval (Var x) (v:values) = if x == fst v 
                          then snd v
                          else eval (Var x) values
eval (Add x y) values = eval x values + eval y values
eval (Mult x y) values = eval x values * eval y values
eval (Let x y ex) values = let 
                            eval_y = eval y values
                           in eval ex ((x, eval_y):values)




-------------------------------------------------------------------------------------------------------------------
{--33.6
Написать функцию toInt, которая по данному числу Черча возвращает обычное число.

Пример вызова:

toInt (\ f x -> f (f (f x)))

Результат должен быть равен 3.

Замечание: 
- Задача очень простая, пишется в одну строку.--}

toInt f = f (+1) 0




-------------------------------------------------------------------------------------------------------------------
{--33.7
Написать функцию inc, которая прибавляет 1 к числу Черча.

Например, вызов inc (\ f x -> f (f (f x))) должен вернуть \ f x -> f (f (f (f x))). 

Пример вызова:
toInt (inc (\ f x -> f (f (f x))))
Результат д.б. равен 4.

Замечания: 
- Это тоже очень простая задача.
- Чтобы тесты прошли, надо добавить в текст программы определение toInt из задачи 33-6--}

inc g = \ f x -> f( g f x)

