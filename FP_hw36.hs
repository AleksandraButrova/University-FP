{--36.1
Пусть мы хотим, чтобы можно было написать: 

f = find (>3) >>>= \x ->
...find (>x) >>>= \y ->
...return1 (x+y)

(как обычно, точки обозначают пробелы).
И в результате f должна работать так: она ищет в списке первый элемент, больший 3, 
потом первый элемент, больший первого найденного и возвращает пару 
(сумма двух найденных чисел, хвост списка).

>>>= мы уже определили на занятиях. Определите return1.

(Подсказка: как это обычно бывает с return, это очень простая функция).
Пример вызова f:

f [1,2,8,4,9,3,25]

Должно получиться (17, [3,25]), потому что первый поиск найдет 8, второй - 9.

Замечание:
- чтобы тесты прошли, в программу надо также переписать определения find и >>>= из слайдов
--}

find cond (x:xs) =  if cond x
                    then (x, xs)
                    else find cond xs
f >>>= g = \xs ->
                let
                    (x, xs1) = f xs
                in g x xs1


return1 = \x xs -> (x, xs) 

f = find (>3) >>>= \x ->
    find (>x) >>>= \y ->
    return1 (x+y)





-------------------------------------------------------------------------------------------------------------
{--36.2
*Чтo-то похожее на елочку, по поводу приближающегося Нового Года*

Опишите функцию elka, которая для данного n печатает n треугольников из семерок, каждый высотой и шириной n. 

Пример вызова:

elka 3

Должно быть напечатано:

7
77
777
7
77
777
7
77
777
--}

printOne a 1 = print a
printOne a n = do
    print a
    printOne (a*10 + 7) (n-1) 

cycle' 1 n = printOne 7 n
cycle' k n = do
    printOne 7 n
    cycle' (k-1) n

elka n = cycle' n n




-------------------------------------------------------------------------------------------------------------
{--36.3
*Снова задача про Expr и Let*

*Обратите внимание, формулировка немного поменялась*. 

Реализовать eval для типа Expr с возможностью задания let выражений. Но при этом рализация должна быть немного другая:
- в списке env должны хранится не числа, а выражения. То есть, например, не ("x", 2), а ("x", Num 2)
- при вычислении env не надо вызывать eval для let выражения, надо просто добавить его в env не вычисляя. 
А eval вызвать потом, когда нам потребуется значение переменной
Примеры вызова:

eval (Add (Let "x" (Add(Num 5)(Num 5)) (Mult (Var "x") (Var "y"))) (Num 1)) [("y", Num 2)]

Результат должен быть равен 21

eval (Add (Let "x" (Var "t") (Mult (Num 10) (Var "y"))) (Num 1)) [("y", Num 2)]

Результат должен быть равен 21, и не должно быть ошибки из-за неизвестной переменной t, 
потому что ее значение и не используется.--}

data Expr = Num Integer | Var String | Add Expr Expr | Mult Expr Expr | Let String Expr Expr

eval (Num i) values = i
eval (Var x) [] = 0
eval (Var x) (v:values) = if x == fst v 
                          then eval (snd v) values
                          else eval (Var x) values
eval (Add x y) values = eval x values + eval y values
eval (Mult x y) values = eval x values * eval y values

eval (Let t ex y) values = eval y ((t, ex) : values)


-- Из условий всё равно немного не понятно куда мы можем вставлять Let
-- Мне было не очевидно сразу, что нужно написать в data (Let String Expr Expr)

-- Изначально я сделала так: (что считаю немного логичнее, но кому как)
-- eval (Add (Let t ex) x) values = eval (Add (Num 0) x ) ((t, ex) : values) 
-- eval (Mult (Let t ex) x) values = eval (Mult (Num 1) x) ((t, ex) : values)
-- Тут и Let остался обычным и всё остальное сохранилось.







----------------------------------------------------------------------------------------------------
{-- 36.6
Описать функцию isPower3 с параметром n, которая возвращает True, если n – степень 3 и False, если нет. 

Дополнительное условие:
- Функцию надо описать с помощью нерекурсивной функции и функции fix (комбинатора неподвижной точки) 

Пример вызова:
isPower3 27
Результат должен быть равен True

Замечание:
- Функцию fix опишите, пожалуйста, в своей программе так же, как в слайдах. 
Или вы можете подключить библиотеку Data.Function, там она определена.--}

fix f = f ( fix f ) 

isPower3' f n | n == 1 = True 
              | otherwise = if mod n 3 == 0
                            then f (div n 3)
                            else False

isPower3 = fix isPower3'








