{--12.1
"Крестик"
Описать функцию cross, которая для данного числа n возвращает список списков, представляющий матрицу,
 в которой на главной и побочной диагоналях стоят 1, а все остальные элементы равны 0.

Примеры вызова:
cross 4
Результат должен быть равен:
[[1,0,0,1],
[0,1,1,0],
[0,1,1,0],
[1,0,0,1]]

cross 5
Результат должен быть равен:
[[1,0,0,0,1],
[0,1,0,1,0],
[0,0,1,0,0],
[0,1,0,1,0],
[1,0,0,0,1]]--}

cross n = map (\i -> [x | y <- [1..n], let x = if (y == i || y == n - i+ 1) 
                                               then 1
                                               else 0 ]) [1..n]



{--12.2
Перечислить все способы выдать данную сумму n монетами по 2, 3 и 5 коп. 
Результат должен быть списком списков целых чисел, каждый внутренний список - 
это список из трех элементов [k,l,m], 
где k - двухкопеечных монет, 
    l - количество трехкопеечных, 
    m - количество пятикопеечных монет. 

Пример вызова: 
coins 10 
Должно получиться: [[5,0,0],[2,2,0],[0,0,2],[1,1,1]] (порядок троек в ответе может быть и другим). 

Замечания:
- Вообще это упражнение на list comprehension. Но, если хотите, вы можете решить задачу и без list comprehension, как хотите.
- Большинство людей эту задачу пишут не совсем эффективно, точнее, не замечают возможность немного 
изменить программу, чтобы она стала гораздо эффективнее. Я ее засчитаю не зависимо от эффективности, но, 
пожалуйста, когда будете писать, подумайте немного, нельзя ли где-то ее улучшить.
--}

coins n = [ [k, l, m] | 
                        k <- [0..(div n 2)],
                        l <- [0..(div n 3)],
                        m <- [0..(div n 2)],
                        k * 2 + l * 3 + m * 5 == n ]



{--12.3
а. Опишите функцию foldTree, которая для дерева делает что-то аналогичное foldr или foldl для списков. 
Она должна вызываться так:

foldTree (+) 0 t — ищет сумму всех элементов в дереве
foldTree (*) 1 t — ищет произведение всех элементов в дереве

б. Но м.б. можно придумать что-то более общее? Например, придумать такой вариант foldTree, 
который позволяет реализовывать более сложные функции (например, искать высоту дерева и т.д.). 
Если придумаете, предложите какой-нибудь такой вариант.

Замечания:
- Условие, естественно, не совсем строгое (но так и в жизни часто бывает..). Если есть вопросы - пишите.
- Пункт б. необязательный (хотя и не особо сложный). Решения, описанного в пункте а. вполне достаточно. 
- В этой задаче тестов не будет. Желательно, чтобы вы включили в текст 1-2 примера того, 
как можно использовать вашу функцию.--}


data Tree a = Empty | Node a (Tree a) (Tree a)

foldTree op e Empty = e
foldTree op e (Node a left right) = foldTree op e left `op`  foldTree op a right

-- examples
-- *Main> foldTree (*) 1 (Node 1 (Node 2 Empty (Node 4 Empty Empty)) Empty)                                          
-- 8                                                                                                                 
-- *Main> foldTree (+) 0 (Node 1 (Node 2 Empty (Node 4 Empty Empty)) Empty)                                          
-- 7                                                                                                                   



{--12.4
Пусть мы хотим описывать в программе на Хаскеле электрические схемы. 
Мы считаем, что электрическая схема - это:
- или сопротивление, тогда известно его величина в омах
- или две схемы, соединенных параллельно - или две схемы, соединенных последовательно 
(На самом деле есть схемы, которые таким способом не описать, ну и ладно..) 

1. Опишите тип (data) Scheme, который позволяет описывать такие схемы. 
2. Опишите функцию totalResistance, у которой один параметр - схема, 
и которая возвращает значение общего сопротивления для этой схемы. 
Например, для двух сопротивлений 4 Ом, соединенных последовательно, функция должна возвращать 8, 
а для двух сопротивлений 4 Ом, соединенных параллельно, функция должна возвращать 2. 

Замечания:
- Для того, чтобы хоть как протестировать программу, включите, пожалуйста в вашу программу такое определение test
test = totalResistance ...описание схемы,состоящей из двух сопротивлений 2 Ом соединенных параллельно, 
к которым присоединено еще одно сопротивление 2 Ом последовательно...
То есть, значение test должно в результате вычислиться равным 3. 
- Если вы забыли, как считать общее сопротивление схемы - напишите, я подскажу :)--}

data Scheme s = Value s | 
                Сonsistently (Scheme s) (Scheme s) |
                Parallel (Scheme s) (Scheme s)

totalResistance (Value s) = s
totalResistance ( Сonsistently s1 s2 ) = totalResistance s1 + totalResistance s2
totalResistance ( Parallel s1 s2 ) = 1 / (1 / totalResistance s1 + 1 / totalResistance s2)

test = totalResistance (Сonsistently (Value 2) ( Parallel (Value 2) (Value 2) ) ) 