{--16.1
*Доп. задача, до 29.10* 
В задаче надо написать две функции.
а. sumDiv n должна вернуть сумму всех делителей числа n, считая 1, но не считая самого n.

Пример вызова:
sumDiv 12
Ответ должен быть равен 1+2+3+4+6=16

б. amicables n, которая возвращает список всех пар дружественных чисел, 
каждое из которых меньше или равно n. 

Пример вызова: 
amicables 1000 
Ответ должен быть равен [(220,284)] 

Справка: Числа a и b называется дружественными, если a равно сумме делителей b, 
а b равно сумме делителей a. 

Замечания:
- Для единообразия давайте включать в список только те пары, 
в которых первое число меньше второго, и пары должны идти в порядке возрастания первых чисел пары.
- Дружественных чисел довольно мало, и, возможно, самым оптимальным было бы 
просто выписать все известные пары, скажем, до 1000000. Но, пожалуйста, 
давайте в это задаче этого не делать. Т.е. дополнительное условие - 
не использовать заранее подготовленные данные о дружественных числах. 
Ещё не загружалось ни одного решения--}



----------------------------------------------------------------------------------------------------
{--16.2
*Доп. задача, до 29.10* 
Описать бесконечный список cantor , содержащий все пары целых положительных чисел (каждую по одному разу). 

Пример вызова: 
take 100 cantor 
Что получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, 
но, например, что-то вроде [(1,1), (1,2), (2,2), (2,1), (1,3) и т.д.--}

cantor  = cn 1 1 
            where cn n k | k > 0 = (n, k) : cn (n+1) (k-1)
                         | otherwise = (1, n) : cn (2) (n-1)



----------------------------------------------------------------------------------------------------
{-- 16-3	
*Доп. задача, до 29.10* 
Описать функцию generalizedCantor с одним параметром n, которая возвращает бесконечный список, 
содержащий все возможные списки из n целых положительных чисел (каждый список по одному разу). 

Пример вызова: 
take 100 (generalizedCantor 3) 
Что при этом получится, не могу сказать, потому что вы можете выбирать разные порядки обхода, 
но начало, видимо, будет [[1,1,1], [1,1,2], и т.д.	--}

digitsToNum (list) = fst ( foldr (\l pair -> (l * 10 ^ snd pair + fst pair, snd pair + 1 )) (0, 0) (list))


gn n  = (replicate n 1) :: ob 1 1 (replicate n 1)
ob pos dir list | pos == 1 = (list !! 1 + dir) :: (drop 1 list)
                | pos == 2 = (list !! 1) :: (list !! 2 + dir) :: (drop 2 list)
                | pos > 2 = (take (pos-1) list)++()

